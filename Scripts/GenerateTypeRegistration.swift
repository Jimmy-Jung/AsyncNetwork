#!/usr/bin/env swift

//
//  GenerateTypeRegistration.swift
//  AsyncNetwork
//
//  Created by jimmy on 2026/01/03.
//
//  ì´ ìŠ¤í¬ë¦½íŠ¸ëŠ” í”„ë¡œì íŠ¸ì˜ ëª¨ë“  @DocumentedType íƒ€ì…ì„ ìŠ¤ìº”í•˜ì—¬
//  ìë™ìœ¼ë¡œ ë“±ë¡í•˜ëŠ” Swift ì½”ë“œë¥¼ ìƒì„±í•©ë‹ˆë‹¤.
//

import Foundation

// MARK: - TypeScanner

/// @DocumentedTypeì´ ì ìš©ëœ íƒ€ì…ì„ ìŠ¤ìº”í•˜ëŠ” í´ë˜ìŠ¤
struct TypeScanner {
    let projectPath: String
    let verbose: Bool
    
    /// ëª¨ë“  @DocumentedType íƒ€ì…ì„ ìŠ¤ìº”í•©ë‹ˆë‹¤
    func scanDocumentedTypes() throws -> [String] {
        var documentedTypes: [String] = []
        
        if verbose {
            print("ğŸ“‚ Scanning project: \(projectPath)")
        }
        
        // ëª¨ë“  .swift íŒŒì¼ ì°¾ê¸°
        let swiftFiles = try findSwiftFiles(in: projectPath)
        
        if verbose {
            print("ğŸ“„ Found \(swiftFiles.count) Swift files")
        }
        
        for file in swiftFiles {
            let content = try String(contentsOfFile: file, encoding: .utf8)
            let types = extractDocumentedTypes(from: content, file: file)
            documentedTypes.append(contentsOf: types)
        }
        
        return documentedTypes.sorted()
    }
    
    /// ì§€ì •ëœ ë””ë ‰í† ë¦¬ì—ì„œ ëª¨ë“  .swift íŒŒì¼ì„ ì°¾ìŠµë‹ˆë‹¤
    private func findSwiftFiles(in directory: String) throws -> [String] {
        let fileManager = FileManager.default
        var swiftFiles: [String] = []
        
        guard let enumerator = fileManager.enumerator(atPath: directory) else {
            throw NSError(
                domain: "TypeScanner",
                code: 1,
                userInfo: [NSLocalizedDescriptionKey: "Cannot enumerate directory: \(directory)"]
            )
        }
        
        while let file = enumerator.nextObject() as? String {
            if file.hasSuffix(".swift") && !file.contains("/Generated/") && !file.hasSuffix("+Generated.swift") {
                swiftFiles.append("\(directory)/\(file)")
            }
        }
        
        return swiftFiles
    }
    
    /// íŒŒì¼ ë‚´ìš©ì—ì„œ @DocumentedTypeì´ ì ìš©ëœ íƒ€ì…ì„ ì¶”ì¶œí•©ë‹ˆë‹¤
    private func extractDocumentedTypes(from content: String, file: String) -> [String] {
        var types: [String] = []
        let lines = content.components(separatedBy: .newlines)
        
        for (index, line) in lines.enumerated() {
            // @DocumentedType ì°¾ê¸°
            let trimmedLine = line.trimmingCharacters(in: .whitespaces)
            if trimmedLine == "@DocumentedType" {
                // ë‹¤ìŒ ì¤„ì—ì„œ íƒ€ì… ì´ë¦„ ì¶”ì¶œ
                if index + 1 < lines.count {
                    let nextLine = lines[index + 1]
                    if let typeName = extractTypeName(from: nextLine) {
                        types.append(typeName)
                        if verbose {
                            let fileName = URL(fileURLWithPath: file).lastPathComponent
                            print("  âœ“ \(typeName) (in \(fileName))")
                        }
                    }
                }
            }
        }
        
        return types
    }
    
    /// ì½”ë“œ ë¼ì¸ì—ì„œ íƒ€ì… ì´ë¦„ì„ ì¶”ì¶œí•©ë‹ˆë‹¤
    private func extractTypeName(from line: String) -> String? {
        // struct Post, class User, enum Status ë“±ì—ì„œ íƒ€ì… ì´ë¦„ ì¶”ì¶œ
        let pattern = #"(struct|class|enum)\s+(\w+)"#
        guard let regex = try? NSRegularExpression(pattern: pattern),
              let match = regex.firstMatch(
                  in: line,
                  range: NSRange(line.startIndex..., in: line)
              ),
              let typeNameRange = Range(match.range(at: 2), in: line) else {
            return nil
        }
        
        return String(line[typeNameRange])
    }
}

// MARK: - CodeGenerator

/// íƒ€ì… ë“±ë¡ ì½”ë“œë¥¼ ìƒì„±í•˜ëŠ” í´ë˜ìŠ¤
struct CodeGenerator {
    let moduleName: String
    let targetName: String
    
    /// ì£¼ì–´ì§„ íƒ€ì… ëª©ë¡ìœ¼ë¡œë¶€í„° ë“±ë¡ ì½”ë“œë¥¼ ìƒì„±í•©ë‹ˆë‹¤
    func generateRegistrationCode(types: [String]) -> String {
        let registrationLines = types.map { "        _ = \($0).typeStructure" }
        
        return """
        //
        //  TypeRegistration+Generated.swift
        //  \(moduleName)
        //
        //  Auto-generated by GenerateTypeRegistration.swift
        //  Created on \(ISO8601DateFormatter().string(from: Date()))
        //
        //  DO NOT EDIT MANUALLY
        //  This file is automatically regenerated during build.
        //
        
        import AsyncNetworkCore
        
        extension \(targetName) {
            /// ëª¨ë“  @DocumentedType íƒ€ì…ì„ ìë™ìœ¼ë¡œ ë“±ë¡í•©ë‹ˆë‹¤
            ///
            /// ì´ ë©”ì„œë“œëŠ” ë¹Œë“œ ì‹œ ìë™ ìƒì„±ë˜ì—ˆìŠµë‹ˆë‹¤.
            /// íƒ€ì…ì„ ì¶”ê°€/ì‚­ì œí•˜ë©´ ë‹¤ìŒ ë¹Œë“œì—ì„œ ìë™ìœ¼ë¡œ ì—…ë°ì´íŠ¸ë©ë‹ˆë‹¤.
            ///
            /// - Note: ìƒì„±ëœ íƒ€ì… ìˆ˜: \(types.count)ê°œ
            func registerAllTypesGenerated() {
        \(registrationLines.joined(separator: "\n"))
            }
        }
        
        """
    }
}

// MARK: - Main Execution

do {
    // ì¸ì íŒŒì‹±
    var projectPath: String?
    var outputPath: String?
    var moduleName = "AsyncNetworkDocKitExample"
    var targetName = "AsyncNetworkDocKitExampleApp"
    var verbose = false
    
    let args = CommandLine.arguments
    var i = 1
    while i < args.count {
        let arg = args[i]
        switch arg {
        case "--project", "-p":
            i += 1
            if i < args.count {
                projectPath = args[i]
            }
        case "--output", "-o":
            i += 1
            if i < args.count {
                outputPath = args[i]
            }
        case "--module", "-m":
            i += 1
            if i < args.count {
                moduleName = args[i]
            }
        case "--target", "-t":
            i += 1
            if i < args.count {
                targetName = args[i]
            }
        case "--verbose", "-v":
            verbose = true
        case "--help", "-h":
            print("""
            Usage: GenerateTypeRegistration.swift [options]
            
            Options:
              -p, --project <path>    í”„ë¡œì íŠ¸ ì†ŒìŠ¤ ë””ë ‰í† ë¦¬ ê²½ë¡œ (í•„ìˆ˜)
              -o, --output <path>     ì¶œë ¥ íŒŒì¼ ê²½ë¡œ (í•„ìˆ˜)
              -m, --module <name>     ëª¨ë“ˆ ì´ë¦„ (ê¸°ë³¸: AsyncNetworkDocKitExample)
              -t, --target <name>     íƒ€ê²Ÿ ì´ë¦„ (ê¸°ë³¸: AsyncNetworkDocKitExampleApp)
              -v, --verbose           ìƒì„¸ ì¶œë ¥
              -h, --help              ë„ì›€ë§ í‘œì‹œ
            
            Example:
              ./GenerateTypeRegistration.swift \\
                --project ./AsyncNetworkDocKitExample/Sources \\
                --output ./AsyncNetworkDocKitExample/Sources/TypeRegistration+Generated.swift
            """)
            exit(0)
        default:
            break
        }
        i += 1
    }
    
    guard let projectPath = projectPath, let outputPath = outputPath else {
        print("âŒ Error: --project and --output are required")
        print("Run with --help for usage information")
        exit(1)
    }
    
    // ë””ë ‰í† ë¦¬ ì¡´ì¬ í™•ì¸
    let fileManager = FileManager.default
    guard fileManager.fileExists(atPath: projectPath) else {
        print("âŒ Error: Project path does not exist: \(projectPath)")
        exit(1)
    }
    
    if verbose {
        print("ğŸ” TypeRegistration Generator")
        print("   Project: \(projectPath)")
        print("   Output:  \(outputPath)")
        print("   Module:  \(moduleName)")
        print("   Target:  \(targetName)")
        print()
    }
    
    // íƒ€ì… ìŠ¤ìº”
    let scanner = TypeScanner(projectPath: projectPath, verbose: verbose)
    let types = try scanner.scanDocumentedTypes()
    
    if verbose {
        print()
    }
    print("âœ… Found \(types.count) @DocumentedType types")
    
    if verbose && !types.isEmpty {
        print("\nTypes:")
        types.forEach { print("  - \($0)") }
    }
    
    // ì½”ë“œ ìƒì„±
    let generator = CodeGenerator(moduleName: moduleName, targetName: targetName)
    let code = generator.generateRegistrationCode(types: types)
    
    // ì¶œë ¥ ë””ë ‰í† ë¦¬ ìƒì„±
    let outputDir = URL(fileURLWithPath: outputPath).deletingLastPathComponent().path
    if !fileManager.fileExists(atPath: outputDir) {
        try fileManager.createDirectory(atPath: outputDir, withIntermediateDirectories: true)
    }
    
    // íŒŒì¼ ì“°ê¸°
    try code.write(toFile: outputPath, atomically: true, encoding: .utf8)
    
    print("ğŸ“ Generated: \(outputPath)")
    
    if verbose {
        print("\nâœ¨ Done!")
    }
    
} catch {
    print("âŒ Error: \(error.localizedDescription)")
    exit(1)
}

